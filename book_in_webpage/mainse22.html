<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="Description" CONTENT="Cálculo Numérico - Um Livro Colaborativo, 
   Instituto de Matemática e Estatística (IME), Universidade Federal do Rio Grande do Sul (UFRGS)."/>
  <title>Cálculo Numérico - Um Livro Colaborative</title>
  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />
  <link href='http://fonts.googleapis.com/css?family=Open Sans:400,700' rel='stylesheet' type='text/css'/>
  <link rel="stylesheet" href="../bootstrap-3.3.5-dist/css/bootstrap.css"/>
  <link rel="stylesheet" type="text/css" href="new_main.css"/> 
</head>
<body>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61232881-2', 'auto');
  ga('send', 'pageview');

</script>

<!--Navigation menu-->
<div class="nav" style="margin-top:5px">
  <div class="container">
    <ul class="pull-left">
      <li><a href="../index.html">Página do Projeto</a></li>
      <li><a href="https://github.com/livroscolaborativos/CalculoNumerico" target="_blanck">Repositório GitHub</a></li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1 align="center">Cálculo Numérico</h1>
    <h2 align="center">Um Livro Colaborativo</h2>
  </div>
</div>



   <!--l. 107--><div class="crosslinks"><p class="noindent">[<a 
href="mainli17.html" >next</a>] [<a 
href="mainli16.html" >prev</a>] [<a 
href="mainli16.html#tailmainli16.html" >prev-tail</a>] [<a 
href="mainli6.html#tailmainse22.html">tail</a>] [<a 
href="mainli16.html#mainse34.html" >up</a>] </p></div>
   <h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
 id="x58-890005.1"></a>O método de Newton para sistemas</h3>
<a 
 id="dx58-89001"></a>
<!--l. 108--><p class="noindent" >Vamos agora construir o método de Newton-Raphson, ou seja, o método de
Newton generalizado para sistemas. Assumimos, portanto, que a função <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><span 
class="rm-lmr-12">) </span>é
diferenciável e que existe um ponto <span 
class="lmmi-12">x</span><sup><span 
class="lmsy8-">&lowast;</span></sup> tal que <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><sup><span 
class="lmsy8-">&lowast;</span></sup><span 
class="rm-lmr-12">) = 0</span>. Seja <span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup> uma
aproximação para <span 
class="lmmi-12">x</span><sup><span 
class="lmsy8-">&lowast;</span></sup>, queremos construir uma nova aproximação <span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">+1)</span></sup> através
da linearização de <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><span 
class="rm-lmr-12">) </span>no ponto <span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup>.
      <ul class="itemize1">
      <li class="itemize">Linearização da função <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><span 
class="rm-lmr-12">) </span>no ponto <span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup>:
      <table 
class="equation-star"><tr><td>
      <center class="math-display" >
      <img 
src="main756x.png" alt="            (k)       ( (k)) (     (k))     (      (k) 2)
F (x) = F (x  ) + JF  x     x &minus; x    + O   &#x2225;x &minus; x  &#x2225;
      " class="math-display" ></center></td></tr></table>
                                                                          

                                                                          
      <!--l. 114--><p class="nopar" >
      </li>
      <li class="itemize">A aproximação <span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup> é definida como o ponto <span 
class="lmmi-12">x </span>em que a linearização
      <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup><span 
class="rm-lmr-12">) + </span><span 
class="lmmi-12">J</span><sub>
<span 
class="lmmi-8">F</span> </sub><img 
src="main757x.png" alt="(   )
 x(k)"  class="left" align="middle"><img 
src="main758x.png" alt="(        )
 x &minus;  x(k)"  class="left" align="middle"> é nula, ou seja:
      <center class="math-display" >
      <img 
src="main759x.png" alt="             (   ) (            )
F (x(k)) + JF  x(k)  x(k+1) &minus; x (k) = 0
      " class="math-display" ></center></li></ul>
<!--l. 119--><p class="indent" >   Supondo que a matriz jacobina seja inversível no ponto <span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup>, temos:
<div class="eqnarray">
   <center class="math-display" >
<img 
src="main760x.png" alt="   ( (k)) ( (k+1)    (k))           (k)
JF  x     x     &minus; x      =   &minus; F (x  )
             (k+1)    (k)         &minus;1(  (k))     (k)
           x     &minus;  x    =   &minus; J F  x    F(x   )
                   (k+1)       (k)    &minus; 1( (k))    (k)
                  x      =   x   &minus; JF   x    F (x  )
" class="math-display" ></center>
</div>
<!--l. 126--><p class="indent" >   Desta forma, o método iterativo de Newton-Raphson para encontrar as raízes
de <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><span 
class="rm-lmr-12">) = 0 </span>é dado por:
   <table 
class="equation-star"><tr><td>
                                                                          

                                                                          
   <center class="math-display" >
<img 
src="main761x.png" alt="(                       (    )
|{ x (k+1)  =   x(k) &minus; J&minus; 1 x(k) F (x(k)), n &ge;  0
                     F
|(    x(0)  =   dado inicial
" class="math-display" ></center></td></tr></table>
<!--l. 132--><p class="nopar" >
   <div class="newtheorem">
<!--l. 134--><p class="noindent" ><span class="head">
<a 
 id="x58-89003r1"></a>
<span 
class="ec-lmbx-12">Observa</span><span 
class="ec-lmbx-12">ç</span><span 
class="ec-lmbx-12">ão 5.1.1.</span>  </span>Usamos subíndices para indicar o elemento de um vetor
e  super-índices  para  indicar  o  passo  da  iteração.  Assim  <span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup>  se  refere  à
iteração <span 
class="lmmi-12">k </span>e <span 
class="lmmi-12">x</span><sub><span 
class="lmmi-8">i</span></sub><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup> se refere à componente <span 
class="lmmi-12">i </span>no vetor <span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup>.
   </div>
   <div class="newtheorem">
<!--l. 136--><p class="noindent" ><span class="head">
<a 
 id="x58-89004r2"></a>
<span 
class="ec-lmbx-12">Observa</span><span 
class="ec-lmbx-12">ç</span><span 
class="ec-lmbx-12">ão 5.1.2.</span>  </span>A notação <span 
class="lmmi-12">J</span><sub><span 
class="lmmi-8">F</span> </sub><sup><span 
class="lmsy8-">&minus;</span><span 
class="rm-lmr-8">1</span></sup><img 
src="main762x.png" alt="( (k))
 x"  class="left" align="middle"> enfatiza que a jacobiana deve
ser calculada a cada passo.
   </div>
   <div class="newtheorem">
<!--l. 138--><p class="noindent" ><span class="head">
<a 
 id="x58-89005r3"></a>
<span 
class="ec-lmbx-12">Observa</span><span 
class="ec-lmbx-12">ç</span><span 
class="ec-lmbx-12">ão 5.1.3.</span>  </span>Podemos definir o passo <span 
class="rm-lmr-12">&Delta;</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup> como
                                                                          

                                                                          
   <center class="math-display" >
<img 
src="main763x.png" alt="&Delta;(k) = x(k+1) &minus; x(k)
" class="math-display" ></center> Assim, <span 
class="rm-lmr-12">&Delta;</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup> <span 
class="rm-lmr-12">= </span><span 
class="lmsy-10x-x-120">&minus;</span><span 
class="lmmi-12">J</span><sub>
<span 
class="lmmi-8">F</span> </sub><sup><span 
class="lmsy8-">&minus;</span><span 
class="rm-lmr-8">1</span></sup><img 
src="main764x.png" alt="(  (k))
  x"  class="left" align="middle"><span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup><span 
class="rm-lmr-12">)</span>, ou seja, <span 
class="rm-lmr-12">&Delta;</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup> resolve o problema linear:
   <center class="math-display" >
<img 
src="main765x.png" alt="   (  (k))  (k)        (k)
JF   x    &Delta;   =  &minus; F(x   )
" class="math-display" ></center> Em geral, é menos custoso resolver o sistema acima do que calcular o inverso
da jacobiana e multiplicar pelo vetor <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><sup><span 
class="rm-lmr-8">(</span><span 
class="lmmi-8">k</span><span 
class="rm-lmr-8">)</span></sup><span 
class="rm-lmr-12">)</span>.
   </div>
   <div class="newtheorem">
<!--l. 145--><p class="noindent" ><span class="head">
<a 
 id="x58-89006r1"></a>
<span 
class="ec-lmbx-12">Exemplo 5.1.1.</span>  </span>Retornamos ao nosso exemplo inicial, isto é, resolver
numericamente os seguinte sistema não-linear: <div class="eqnarray">
   <center class="math-display" >
<img 
src="main766x.png" alt="x21     2
---+ x 2 =   1
 3    2
x2 + x2- =   1
 1    4
" class="math-display" ></center>
</div>Para tal, definimos a função <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><span 
class="rm-lmr-12">)</span>:
   <table 
class="equation-star"><tr><td>
   <center class="math-display" >
<img 
src="main767x.png" alt="        &lfloor; x2          &rfloor;
        | -1-+ x22 &minus; 1 |
F (x) = |&lceil;  3    2     |&rceil;
          x21 + x2-&minus; 1
                4
" class="math-display" ></center></td></tr></table>
<!--l. 158--><p class="nopar" >
cuja jacobiana é:
   <table 
class="equation-star"><tr><td>
   <center class="math-display" >
<img 
src="main768x.png" alt="      &lfloor;           &rfloor;
        2x1-  2x
JF  = |&lceil;  3      2 |&rceil;
        2x     x2
           1   2
" class="math-display" ></center></td></tr></table>
<!--l. 165--><p class="nopar" >
                                                                          

                                                                          
<!--l. 168--><p class="indent" >   Faremos a implementação numérica no <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-12">Scilab</span></span></span>. Para tal definimos as funções
que implementarão <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><span 
class="rm-lmr-12">) </span>e a <span 
class="lmmi-12">J</span><sub><span 
class="lmmi-8">F</span> </sub><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><span 
class="rm-lmr-12">)</span>
                                                                          

                                                                          
   <div class="verbatim" id="verbatim-36">
function&#x00A0;y=F(x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(1)=x(1)^2/3+x(2)^2-1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(2)=x(1)^2+x(2)^2/4-1
&#x00A0;<br />endfunction
&#x00A0;<br />
&#x00A0;<br />function&#x00A0;y=JF(x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(1,1)=2*x(1)/3
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(1,2)=2*x(2)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(2,1)=2*x(1)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(2,2)=x(2)/2
&#x00A0;<br />endfunction
</div>
<!--l. 181--><p class="nopar" >Alternativamente, estas funções poderiam ser escritas como
                                                                          

                                                                          
   <div class="verbatim" id="verbatim-37">
function&#x00A0;y=F(x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y=[x(1)^2/3+x(2)^2-1;&#x00A0;x(1)^2+x(2)^2/4-1]
&#x00A0;<br />endfunction
&#x00A0;<br />
&#x00A0;<br />function&#x00A0;y=JF(x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y=[2*x(1)/3&#x00A0;&#x00A0;2*x(2);&#x00A0;2*x(1)&#x00A0;x(2)/2]
&#x00A0;<br />endfunction
</div>
<!--l. 191--><p class="nopar" >Desta forma, se <span 
class="lmmi-12">x </span>é uma aproximação para a raiz, pode-se calcular a próxima
aproximação através dos comandos:
                                                                          

                                                                          
   <div class="verbatim" id="verbatim-38">
delta=-JF(x)\F(x)
&#x00A0;<br />x=x+delta
</div>
<!--l. 196--><p class="nopar" >Ou simplesmente
                                                                          

                                                                          
   <div class="verbatim" id="verbatim-39">
x=x-JF(x)\F(x)
</div>
<!--l. 200--><p class="nopar" >Observe que as soluções exatas desse sistema são <img 
src="main769x.png" alt="( &#x2218; -9-   &#x2218; 8-)
 ±   11, ±   11"  class="left" align="middle">.
   </div>
   <div class="newtheorem">
<!--l. 206--><p class="noindent" ><span class="head">
<a 
 id="x58-89008r2"></a>
<span 
class="ec-lmbx-12">Exemplo 5.1.2.</span>  </span>Encontre uma aproximação para a solução do sistema
<div class="eqnarray">
   <center class="math-display" >
<img 
src="main770x.png" alt="x2 = cos(x x ) + 1
 1        1  2
sin(x2) = 2cos(x1)
" class="math-display" ></center>
</div>que fica próxima ao ponto <span 
class="lmmi-12">x</span><sub><span 
class="rm-lmr-8">1</span></sub> <span 
class="rm-lmr-12">= 1</span><span 
class="lmmi-12">.</span><span 
class="rm-lmr-12">5 </span>e <span 
class="lmmi-12">x</span><sub><span 
class="rm-lmr-8">2</span></sub> <span 
class="rm-lmr-12">= </span><span 
class="lmmi-12">.</span><span 
class="rm-lmr-12">5</span>.<br 
class="newline" /><span 
class="ec-lmbx-12">Resp: </span><span 
class="rm-lmr-12">(1</span><span 
class="lmmi-12">,</span><span 
class="rm-lmr-12">3468109</span><span 
class="lmmi-12">,</span><span 
class="lmmi-12">&#x00A0;</span><span 
class="rm-lmr-12">0</span><span 
class="lmmi-12">,</span><span 
class="rm-lmr-12">4603195)</span>.
   </div>
<!--l. 214--><p class="indent" >
   <div class="proof">
<!--l. 214--><p class="indent" >   <span class="head">
                                                                          

                                                                          
<span 
class="ec-lmbx-12">Solu</span><span 
class="ec-lmbx-12">ç</span><span 
class="ec-lmbx-12">ão.</span> </span> Vamos, aqui, dar as principais ideias para se obter a solução.
Começamos definindo a função <span 
class="lmmi-12">F</span><span 
class="rm-lmr-12">(</span><span 
class="lmmi-12">x</span><span 
class="rm-lmr-12">) </span>por:
   <table 
class="equation-star"><tr><td>
   <center class="math-display" >
<img 
src="main771x.png" alt="        &lfloor;                    &rfloor;
        | x21 &minus; cos(x1x2) &minus; 1 |
F(x ) = &lceil;                    &rceil;
          sin (x2 ) &minus; 2 cos(x1)
" class="math-display" ></center></td></tr></table>
<!--l. 220--><p class="nopar" >
cuja jacobiana é:
   <table 
class="equation-star"><tr><td>
   <center class="math-display" >
<img 
src="main772x.png" alt="         &lfloor;                                &rfloor;
         | 2x1 + x2sin(x1x2)  x1 sin(x1x2 )|
JF(x ) = &lceil;                                &rceil;
               2 sin (x1)        cos(x2)
" class="math-display" ></center></td></tr></table>
<!--l. 227--><p class="nopar" >
No <span class="obeylines-h"><span class="verb"><span 
class="ec-lmtt-12">Scilab</span></span></span>, podemos implementá-las com o seguinte código:
                                                                          

                                                                          
   <div class="verbatim" id="verbatim-40">
function&#x00A0;y=F(x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(1)&#x00A0;=&#x00A0;x(1)^2-cos(x(1)*x(2))-1
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(2)&#x00A0;=&#x00A0;sin(x(2))-2*cos(x(1))
&#x00A0;<br />endfunction
&#x00A0;<br />
&#x00A0;<br />function&#x00A0;y=JF(x)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(1,1)&#x00A0;=&#x00A0;2*x(1)+x(2)*sin(x(1)*x(2))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(1,2)&#x00A0;=&#x00A0;x(1)*sin(x(1)*x(2))
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(2,1)&#x00A0;=&#x00A0;2*sin(x(1))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;y(2,2)&#x00A0;=&#x00A0;cos(x(2))
&#x00A0;<br />endfunction
</div>
<!--l. 243--><p class="nopar" >
<!--l. 245--><p class="indent" >   E agora, basta iterar:
                                                                          

                                                                          
   <div class="verbatim" id="verbatim-41">
x=[1.5;&#x00A0;.5]
&#x00A0;<br />x=x-JF(x)\F(x)&#x00A0;(5&#x00A0;vezes)
</div>
<!--l. 249--><p class="nopar" >                                                                         <span 
class="msam-10x-x-120">&#x2662;</span>
   </div>
<!--l. 254--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.1   </span> <a 
 id="x58-900005.1.1"></a>Código Scilab: Newton para Sistemas</h4>
   <div class="verbatiminput">
<span 
class="ec-lmtt-12">function</span><span 
class="ec-lmtt-12">&#x00A0;[x]</span><span 
class="ec-lmtt-12">&#x00A0;=</span><span 
class="ec-lmtt-12">&#x00A0;newton(F,JF,x0,TOL,N)</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;x</span><span 
class="ec-lmtt-12">&#x00A0;=</span><span 
class="ec-lmtt-12">&#x00A0;x0</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;k</span><span 
class="ec-lmtt-12">&#x00A0;=</span><span 
class="ec-lmtt-12">&#x00A0;1</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;//iteracoes</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;while</span><span 
class="ec-lmtt-12">&#x00A0;(k</span><span 
class="ec-lmtt-12">&#x00A0;&#x003C;=</span><span 
class="ec-lmtt-12">&#x00A0;N)</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;//iteracao</span><span 
class="ec-lmtt-12">&#x00A0;de</span><span 
class="ec-lmtt-12">&#x00A0;Newton</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;delta</span><span 
class="ec-lmtt-12">&#x00A0;=</span><span 
class="ec-lmtt-12">&#x00A0;-inv(JF(x))*F(x)</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;x</span><span 
class="ec-lmtt-12">&#x00A0;=</span><span 
class="ec-lmtt-12">&#x00A0;x</span><span 
class="ec-lmtt-12">&#x00A0;+</span><span 
class="ec-lmtt-12">&#x00A0;delta</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;//criterio</span><span 
class="ec-lmtt-12">&#x00A0;de</span><span 
class="ec-lmtt-12">&#x00A0;parada</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;if</span><span 
class="ec-lmtt-12">&#x00A0;(norm(delta,</span><span 
class="ts1-lmtt12-">&#8217;</span><span 
class="ec-lmtt-12">inf</span><span 
class="ts1-lmtt12-">&#8217;</span><span 
class="ec-lmtt-12">)&#x003C;TOL)</span><span 
class="ec-lmtt-12">&#x00A0;then</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;return</span><span 
class="ec-lmtt-12">&#x00A0;x</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;end</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;k</span><span 
class="ec-lmtt-12">&#x00A0;=</span><span 
class="ec-lmtt-12">&#x00A0;k+1</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;end</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">&#x00A0;</span><span 
class="ec-lmtt-12">&#x00A0;error(</span><span 
class="ts1-lmtt12-">&#8217;</span><span 
class="ec-lmtt-12">Num.</span><span 
class="ec-lmtt-12">&#x00A0;de</span><span 
class="ec-lmtt-12">&#x00A0;iter.</span><span 
class="ec-lmtt-12">&#x00A0;max.</span><span 
class="ec-lmtt-12">&#x00A0;atingido!</span><span 
class="ts1-lmtt12-">&#8217;</span><span 
class="ec-lmtt-12">)</span>
<span 
class="ec-lmtt-12">&#x00A0;</span><br /><span 
class="ec-lmtt-12">endfunction</span>
   </div>
                                                                          

                                                                          
   <!--l. 259--><div class="crosslinks"><p class="noindent">[<a 
href="mainli17.html" >next</a>] [<a 
href="mainli16.html" >prev</a>] [<a 
href="mainli16.html#tailmainli16.html" >prev-tail</a>] [<a 
href="mainse22.html" >front</a>] [<a 
href="mainli16.html#mainse34.html" >up</a>] </p></div>
<!--l. 259--><p class="indent" >   <a 
 id="tailmainse22.html"></a>   
<div class="panel-footer">
  <p align="center">
    <img src="../favicon.ico" alt="UFRGS"> UFRGS - IME - Cálculo Numérico - Um Livro Colaborativo. Contato: <a href="mailto:livroscolaborativos@gmail.com" target="_top">livroscolaborativos@gmail.com</a>
    </img>
  </p>
</div>
</body>
</html>
